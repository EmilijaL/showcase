<ui:composition template="/WEB-INF/templates/showcase.xhtml"
	xmlns="http://www.w3.org/1999/xhtml"
	xmlns:f="http://java.sun.com/jsf/core"
	xmlns:h="http://java.sun.com/jsf/html"
	xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:o="http://omnifaces.org/ui"
	xmlns:of="http://omnifaces.org/functions"
>
	<ui:define name="description">
		<p>
			The CDI annotation <code>@Param</code> allows you to inject, convert and validate a HTTP request parameter
			in a CDI managed bean. It's basically like <code>&lt;f:viewParam&gt;</code>, but with the major difference
			that the injected HTTP request parameter is available during <code>@PostConstruct</code>, allowing a much easier
			way of processing without the need for a <code>&lt;f:event type="preRenderView"&gt;</code>. 
		</p>
	</ui:define>

	<ui:define name="demo">
		<p>
			Click the links below and:
		</p>
		<ul>
			<li>The parameter "text1" is injected as <code>String</code>(*) and is validated as JSF <code>required="true"</code></li>
			<li>The parameter "text2" is injected as <code>String</code> and is validated as 
				JSF <code>&lt;f:validateLength minimum="3"&gt;
			</code></li>
			<li>The parameter "text3" is injected as <code>String</code> and is validated as JSR303 (Bean Validation) <code>@NotNull</code>(**)</li>
			<li>The parameter "number" is injected as <code>Integer</code> with automatic JSF integer conversion</li>
			<li>The parameter "date" is injected as <code>Date</code> and is converted as 
				JSF <code>&lt;f:convertDateTime pattern="yyyyMMdd"&gt;</code>
			</li>
			<li>The parameter "nsEntity" is injected as <code>NonSerializableEntity</code> and is 
				converted as JSF <code>&lt;f:converter converterId="nonSerializableEntityConverter"/&gt;</code>
				<small>(the example also demonstrates support for non-serializable values, which is important for CDI's passivating scopes)</small>
			</li>
		</ul>
		
		<ul>
			<li>
				<h:link value="Set all params">
					<f:param name="text1" value="foo" />
					<f:param name="text2" value="bar" />
					<f:param name="text3" value="baz" />
					<f:param name="number" value="42" />
					<f:param name="date" value="19780326" />
					<f:param name="nsEntity" value="abc" />
				</h:link>
			</li>
			<li>
				<h:link value="Omit required param and set wrong values on others">
					<f:param name="text2" value="x" />
					<f:param name="number" value="NaN" />
					<f:param name="date" value="26 Mar 1978" />
				</h:link>
			</li>
		</ul>
		<p>Result: #{cdiParamBean.result}</p>
		<h:messages styleClass="messages" errorClass="error" />
		
		<p>
			*) <code>String</code> is actually not injected itself, but is wrapped in a value holder class called <code>ParamValue</code>. This is
			due to the fact that a CDI producer cannot produce an arbitrary object and a parameterized wrapper type is needed. For OmniFaces 1.7
			we plan to look into a CDI extension to work around this and directly inject the converted type. <code>ParamValue</code> does have
			merit on its own though, as it allows access to the raw (non-converted) value and allows non-serializable types to be injected into
			a passivation capable bean. This last feature works by reconverting from the raw value after a bean is restored (changes made to the
			converted instance before passivation took place will be lost though).
		</p>
		
		<p>
			**) <b>NOTE:</b> bean validation at the moment is done against the <code>ParamValue</code> instance that is injected. 
			In many cases this will only be of limited use. We hope to directly inject the converted type in OmniFaces 1.7 and then bean validation 
			will make more sense.
		</p>
		
	</ui:define>
</ui:composition>